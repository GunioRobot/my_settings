#compdef ctags etags

_ctags()
{
    _define_common_languages

    local args
    args=(
        '-a[Append the tags to an existing tag file]:append:(yes no)'
        '--append=[Append the tags to an existing tag file]:append:(yes no)'
        '-B[Use backward searching patterns]'
        '-e[Output tag file for use with Emacs]'
        '-f[Write tags to specified file]:tag file:_files'
        '-F[Use forward searching patterns (default)]'
        '-h[Specify list of file extensions to be treated as include files]:ext list:'
        '-I[A list of tokens to be specially handled, the command line or the specified file]:token list:_files'
        '-L[A list of source file names are read from the specified file]:source files:_files'
        '-n[Equivalent to --excmd=number]'
        '-N[Equivalent to --excmd=pattern]'
        '-o[Write tags to specified file]:tag file:_files'
        '-R[Recurse into directories]'
        '--recurse=[Recurse into directories]:recurse:(yes no)'
        '-u[Should tags be sorted (ignore case)]'
        '--sort=[Should tags be sorted (ignore case)]:sort:(yes no foldcase)'
        '-V[Enable verbose messages describing actions on each source file]'
        '--verbose=[Enable verbose messages describing actions on each source file]:verbose:(yes no)'
        '-x[Print a tabular cross reference file to standard output]'
        "--etags-include=[Include reference to 'file' in Emacs-style tag file (requires -e)]:etag file:_files"
        "--exclude=[Exclude files and directories matching 'pattern']:pattern:"
        '--excmd=[Uses the specified type of EX command to locate tags]:EX command:(number pattern mix)'
        '--extra=[Include extra tag entries for selected information]:extra tag flags:_extra_flags'
        '--fields=[Include selected extension fields]:field flags:_field_flags'
        '--file-scope=[Should tags scoped only for a single file]:file scope:(yes no)'
        '--filter=[Behave as a filter, reading file names from standard input and writing tags to standard output]:filter:(yes no)'
        '--filter-terminator=[Specify string to print to stdout following the tags for each file parsed]:terminator:'
        "--format=[Force output of specified tag file format]:format level:((1\:'the original tag file format' 2\:'a new extended format containing extension fields'))"
        '--help'
        '--if0=[Should C code within #if 0 conditional branches be parsed]:#if:(yes no)'
        '--langdef=[Define a new language to be parsed with regular expressions]:language definition:'
        '--langmap=[Override default mapping of language to source file extension]:language mapping:'
        '--language-force=[Force all files to be interpreted using specified language]:language force:_languages'
        '::target:_files'
    )

    _arguments $args
}

_complete_flags()
{
    local _current_str _current_flags _base_flags _all_flags
    _current_str=${words[CURRENT]##*=}
    for i in {1..${#_current_str}}; do
        _current_flags=( ${_current_flags} ${_current_str[$i]} )
    done

    _base_flags=( $@ )

    if [[ -z ${_current_str} ]]; then
        _base_flags=( ${_base_flags} "+" "-" )
    fi

    local flag_name
    for flag in ${_base_flags}; do
        flag_name="${flag%:*}"
        if [[ -z ${_current_str[(r)${flag_name}]} ]]; then
            _all_flags=( ${_all_flags} "${_current_str}$flag" )
            if [[ ${_current_str} != "+" && ${_current_str} != "-" ]]; then
                _all_flags=( ${_all_flags} ${_current_str} )
            fi
        fi
    done

    _describe -t extra "extra flags" _all_flags || compadd "$@"
}

(( $+functions[_extra_flags()] )) || _extra_flags()
{
    _flags=(
        'f:Include an entry for the base file name of every source file'
        'q:Include an extra class-qualified tag entry for each tag which is a member of a class'
    )

    _complete_flags ${_flags}
}

(( $+functions[_field_flags()] )) || _field_flags()
{
    _flags=(
        'a:Access (or export) of class members'
        'f:File-restricted scoping [enabled]'
        'i:Inheritance information'
        'k:Kind of tag as a single letter [enabled]'
        'K:Kind of tag as full name'
        'l:Language of source file containing tag'
        'm:Implementation information'
        'n:Line number of tag definition'
        's:Scope of tag definition [enabled]'
        'S:Signature of routine (e.g. prototype or parameter list)'
        'z:Include the "kind:" key in kind field'
        't:Type and name of a variable or typedef as "typeref:" field [enabled]'
    )

    _complete_flags ${_flags}
}

(( $+functions[_define_common_languages()] )) || _define_common_languages()
{
    _common_languages=(
        'asm'
        'asp'
        'awk'
        'beta'
        'c'
        'c++'
        'c#'
        'cobol'
        'eiffel'
        'erlang'
        'fortran'
        'html'
        'java'
        'lisp'
        'lua'
        'make'
        'pascal'
        'perl'
        'php'
        'python'
        'rexx'
        'ruby'
        'scheme'
        'sh'
        'slang'
        'sml'
        'sql'
        'tcl'
        'vera'
        'verilog'
        'vim'
        'yacc'
    )
}

(( $+functions[_languages()] )) || _languages()
{
    compadd "$@" -a -- _common_languages
}

_ctags "$@"
